<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>The Code</title>

    <!-- Bootstrap core CSS -->
	<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">

    <!-- Just for debugging purposes. Don't actually copy this line! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Custom styles for this template -->
    <link href="carousel.css" rel="stylesheet">
  </head>
  <body>

    <div class="navbar-wrapper">
      <div class="container">

        <div class="navbar navbar-inverse navbar-static-top" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="/">WCS Advanced Topics Robot</a>
            </div>
            <div class="navbar-collapse collapse">
              <ul class="nav navbar-nav">
                <li class="active"><a href="/">Home</a></li>
                <li class="dropdown">
                  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Project Details<b class="caret"></b></a>
                  <ul class="dropdown-menu">
                    <li><a href="/code.html">The Code</a></li>
                    <li><a href="/robot.html">The Robot</a></li>
                    <li><a href="/pi.html">Raspberry Pi</a></li>

                  </ul>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      </div>





<div class="container">
<div class="row" id="maincontainer">

                    <h1>Checkers Engine </h1>
<p>The piece of the entire program that allows the computer to find the best move it can make is the AIEngine class.  Each player has an AIEngine as its brain, which it can call upon to determine the best move in a situation.  The AIEngine itself is abstract, meaning it cannot be instantiated, but it has multiple subclasses for the different versions of the AI. </p>

<p>All of the AIs we have created work in basically the same way, based on the minimax technique of minimizing the opponent’s maximum possible score.  They all have a function called rankBestMove, which takes a few arguments which convey the state of the game, as well as an argument for the number of moves to calculate ahead.  It then goes through a process to list all of the possible moves for the next turn in order from best to worst.</p>

<p>It starts out this process by finding all of the possible moves for that player on that turn.  Then, it calculates the value of each move by calling the valueOfMoves function, an essential part of the AI which assigns a point value to each possible move.  Finally, it sorts all of the moves based on these values and returns them in the correct order. </p>

<p>The valueOfMoves Function:</p>

<p>The valueOfMoves function is recursive.  It takes some arguments to convey the state of the game, as well as an argument for the number of moves to calculate ahead, as well as some arguments for alpha-beta pruning, which I will discuss later.  It also starts by finding all possible moves for the specified player on the current turn.  It then creates a new game based on each of the possible moves.  It calls itself to get the opponent’s best move for each of these new games, but thinking one less move ahead than the number that was initially passed in.</p>

<p>It keeps doing this, with the number of moves to think ahead counting down with each new set of moves that is created, until the number of moves to think ahead is only one.  At this point, it evaluates each board based on a scoring function built into the board itself.  It then returns the value of the best board for that player.  It will keep returning back up the game tree, with each player picking the move which is best for them.  It will eventually get back to the highest level of the tree, and will then be able to pick which of that original set of moves is best.</p>

<p>Making it all go faster:</p>

<p>There are a few things that we have added in order to make the computer think faster without actually changing the move it picks at all.  These two techniques, multithreading and alpha-beta pruning, allow the computer to be just as good while taking much less time.</p>

<p>Multithreading:</p>

<p>The AI is able to split the moves to calculate between different threads, allowing it to calculate multiple moves at the same time.  When the AI is first asked to sort a list of moves, it creates a pool of threads and assigns a few of the moves to each.  Each thread then does all of the recursion for that move on its own, returning the final value and allowing the moves to be sorted.</p>

<p>Alpha-Beta Pruning:</p>

<p>This technique allows the AI to eliminate some moves without having to calculate all of the possibilities.  When it is a few layers deep into the tree, it knows that the opponent is going to pick its own best move, or the worst of the moves for you when the function returns to the next layer up.  Because of this, if any of the moves in the current layer are bad, the function knows that the opponent will pick the bad one.  The function keeps track of the best move that you currently have available.  If any of the moves are worse than that best move, it knows that the opponent will pick the bad move, and then you will pick the move that you already knew was better.  Based on this knowledge, if any the moves in a portion of the tree are worse than the current best move, the entire section of the tree can be thrown out.</p>

<hr width="50%" size="10" align="center" color="#0B6121">

<p>The AI itself is only a small part of the picture, and would not work without the other classes involved to store the game states, boards, pieces, and players.  The functionality of our checkers game is object oriented. We use 9 core classes for basic game behaviour:</p>
<ol>
<li>Game - This is the overall class that holds a snapshot of the game at one moment. These are passed around and modified when the AI is deciding the values of moves. It holds the game board and both players.</li>

<li>Board - Boards are always contained inside of game instances. When being passed around, they are almost always passed in a Game instance and then accessed through the Game. One very important function of Board is calcuclateValue(). The AI functions by looking at all (or most) foreseeable game states and then decides the best move. In order to pick the best move, the AI needs a way to interpret these boards as numerical values to evaluate. Thats where calculateValue comes in. It assigns numerical Board values based mostly on your number of pieces compared to the opponent’s number of pieces. Extra value is assigned to kings and regular pieces that are close to becoming kings.</li>

<li>Piece - Pieces store information about color, location, king status and represent actual pieces on the board. These values are stored inside instances of Game and are removed when they are jumped. It also contains references to the player that owns it and the board it is on. Every time a new Game and Board are created for recursion, new Piece objects are also created to prevent unintentional cross referencing.</li>

<li>Move - Move is a move (not necessarily valid) that a piece can perform. In it’s most primary state these moves are defined as the movingPiece, and the waypoints in will occupy in the process of the move. For Example, a double jump would have three waypoints. A move has the ability to test validity of itself as well as calculate what pieces would be jumped if the Move were to be performed. </li>

<li>Player - Player is an abstract class, which means it cannot be instantiated, only it’s subclasses. Every game has two players. Players are stored within Games, and are hierarchally parallel to Boards. While players have pieces they are not stored within the Player.java class. Rather, the Player accesses the Board of the Game it belongs to, and retrieves its pieces from there. Players, in general, are capable of calculating all valid Moves and performing desired Moves. More specific tasks are handled by subclasses.</li>

<li>Human - Human is the first subclass of Player. It is used when a player’s moves will be inputted manually. It contains all features of it’s parent class, while adding the ability to prompt for, and input, desired moves.</li>

<li>SimPlayer - SimPlayer is the second subclass of Player. It is to be used when desired moves are to evaluated by the computer. It maintains the ability to have a Robot passed in. Moves will always be performed in the computer’s memory, however if a Robot is passed in, it will also pass performed Moves into that object as well. SimPlayer’s contain AIEngines to make Move evaluations and decisions.</li>



</ol></div>
</div>


    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <script src="docs.min.js"></script>
  </body>
</html>


